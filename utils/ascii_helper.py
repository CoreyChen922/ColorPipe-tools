""" Ascii 1D/2D LUT helpers

.. moduleauthor:: `Marie FETIVEAU <github.com/mfe>`_

"""
__version__ = "0.3"
from utils.abstract_lut_helper import AbstractLUTHelper
import utils.lut_presets as presets
from utils.lut_utils import get_bitdepth


class AsciiHelperException(Exception):
    """Module custom exception

    Args:
        Exception

    """
    pass


class AsciiLutHelper(AbstractLUTHelper):
    """ Simple Ascii 1D/2D LUT.
        Supported by Scratch and others
        Looks Like :
        #Mikros LutUtils export
        LUT: 3 1024
        <r value>
        <r value>
        (...)
        <g value>
        <g value>
        (...)
        <b value>
        <b value>
        (...)

    """
    @staticmethod
    def get_default_preset():
        return {
                presets.TYPE: "1D",
                presets.EXT: '.lut',
                presets.IN_RANGE: [0, 1023],
                presets.OUT_RANGE: [0, 1023],
                presets.OUT_BITDEPTH: 10,
                presets.TITLE: "Ascii LUT",
                presets.COMMENT: ("Generated by ColorPipe-tools, ascii_helper "
                                 "{0}").format(__version__),
                presets.VERSION: "1",
                presets.IS_FLOAT: False,
                presets.LAYOUT: presets.BLOCK_LAYOUT,
                presets.HEADER_TYPE: None
                }

    def _write_1d_2d_lut(self, process_function, file_path, preset,
                         line_function):
        # check range only if LUT isn't float
        should_check = True
        if presets.IS_FLOAT in preset and preset[presets.IS_FLOAT]:
            should_check = False
        if should_check:
            # check range
            for str_range in [presets.IN_RANGE, presets.OUT_RANGE]:
                arange = preset[str_range]
                presets.check_range_is_int(arange,
                                           self. _get_range_message(str_range,
                                                                    arange))
            # output range max value must be equal to output bitdepth max value
            output_range_maxvalue = preset[presets.OUT_RANGE][1]
            bitdepth_size = pow(2, preset[presets.OUT_BITDEPTH])
            bitdepth_maxvalue = bitdepth_size - 1
            outbitdepth = presets.OUT_BITDEPTH
            if  output_range_maxvalue != bitdepth_maxvalue:
                raise AsciiHelperException(("Output range max value ({0}) "
                                            "must be in adaquation with out "
                                            "bitdepth ({1} bits --> {2} "
                                            "max value)"
                                            ).format(output_range_maxvalue,
                                                     preset[outbitdepth],
                                                     bitdepth_maxvalue))
        # get data
        data = self._get_1d_data(process_function, preset)
        lutfile = open(file_path, 'w+')
        # header
        header = preset[presets.HEADER_TYPE]
        if header:
            if header == presets.SCRATCH_HEADER:
                # ex: LUT: 1 1024
                lutfile.write('LUT: ')
                if preset[presets.TYPE] == '2D':
                    lutfile.write('3 ')
                else:
                    lutfile.write('1 ')
                lutfile.write("{0}\n".format(bitdepth_size))
            elif header == presets.LUSTRE_HEADER:
                # ex: LUT16 from 16
                if preset[presets.IS_FLOAT]:
                    raise AsciiHelperException(("An 1D Lustre LUT must have"
                                                " int ranges and ascii "
                                                "is_float option set to "
                                                "false !"))

                in_bit_depth = get_bitdepth(preset[presets.IN_RANGE][1])
                out_bit_depth = get_bitdepth(preset[presets.OUT_RANGE][1])
                lutfile.write("LUT{0} from {1}\n\n".format(in_bit_depth,
                                                           out_bit_depth))
            else:
                # write custom header
                lutfile.write("{0}\n".format(header))
        # data
        if preset[presets.LAYOUT] == presets.BLOCK_LAYOUT:
            # line_function mustn't be used here
            for rgb in data:
                lutfile.write(self._get_pattern_1d(preset).format(rgb.r))
            if preset[presets.TYPE] == '2D':
                for rgb in data:
                    lutfile.write(self._get_pattern_1d(preset).format(rgb.g))
                for rgb in data:
                    lutfile.write(self._get_pattern_1d(preset).format(rgb.b))
        elif preset[presets.LAYOUT] == presets.TRIPLET_LAYOUT:
            index = 0
            for rgb in data:
                line = line_function(preset, rgb,
                                     separator=preset[presets.SEPARATOR])
                # add alpha value if necessary
                if preset[presets.WRITE_ALPHA]:
                    line = line.strip()
                    if preset[presets.IS_FLOAT]:
                        alpha = '0.0'
                    else:
                        alpha = '0'
                    line = "{0}{1}{2}\n".format(line,
                                                preset[presets.SEPARATOR],
                                                alpha)

                # add index value if necessary
                if preset[presets.WRITE_INDEX]:
                    line = "{0}{1}{2}".format(index,
                                              preset[presets.SEPARATOR],
                                              line)
                lutfile.write(line)
                index += 1
        lutfile.close()
        return self.get_export_message(file_path)

    def write_1d_lut(self, process_function, file_path, preset):
        preset[presets.TYPE] = '1D'
        return AbstractLUTHelper.write_1d_lut(self, process_function,
                                              file_path, preset)

    def write_2d_lut(self, process_function, file_path, preset):
        preset[presets.TYPE] = '2D'
        return AbstractLUTHelper.write_2d_lut(self, process_function,
                                              file_path, preset)

    def write_3d_lut(self, process_function, file_path, preset):
        message = "3D  LUT is not supported in Ascii format"
        raise AsciiHelperException(message)

    @staticmethod
    def _get_range_message(range_name, arange):
        """ Get range warning/error message

        Returns:
            .str

        """
        return ("Ascii {0} is expected to be int."
                " Ex: [0, 1023] or [0, 65535].\nYour range {1}"
                ).format(range_name, arange)

    def _validate_preset(self, preset, mode=presets.RAISE_MODE,
                         default_preset=None):
        default_preset = self.get_default_preset()
        # type must be 1D/2D, there's no 3D ascii LUT
        if (presets.TYPE in preset
            and (not (preset[presets.TYPE] == '1D'
                  or preset[presets.TYPE] == '2D'))):
            if mode == presets.RAISE_MODE:
                raise AsciiHelperException(("'{0}' is not a valid type for "
                                            "ascii LUT. Choose '1D' or '2D'"
                                           ).format(preset[presets.TYPE]))
            preset[presets.TYPE] = default_preset[presets.TYPE]
        # Specific attribute (do not raise)
        if not presets.IS_FLOAT in preset:
            preset[presets.IS_FLOAT] = default_preset[presets.IS_FLOAT]
        if not presets.LAYOUT in preset:
            preset[presets.LAYOUT] = default_preset[presets.LAYOUT]
        if preset[presets.LAYOUT] == presets.TRIPLET_LAYOUT:
            if not presets.WRITE_INDEX in preset:
                preset[presets.WRITE_INDEX] = False
            if not presets.WRITE_ALPHA in preset:
                preset[presets.WRITE_ALPHA] = False
            if not presets.SEPARATOR in preset:
                preset[presets.SEPARATOR] = ' '
        elif preset[presets.LAYOUT] != presets.BLOCK_LAYOUT:
            raise AsciiHelperException(("'{0}' is not a valid layout type for "
                                        "ascii LUT. Choose {1} or {2}"
                                        ).format(preset[presets.LAYOUT],
                                                 presets.BLOCK_LAYOUT,
                                                 presets.TRIPLET_LAYOUT))
        if not presets.HEADER_TYPE in preset:
            preset[presets.HEADER_TYPE] = None
        # check basic arguments
        return AbstractLUTHelper._validate_preset(self, preset, mode,
                                                  default_preset)

ASCII_HELPER = AsciiLutHelper()
